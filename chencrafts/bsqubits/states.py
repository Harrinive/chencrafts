import numpy as np
import qutip as qt
from typing import List

from scqubits import HilbertSpace

def coherent_coef_list(n, alpha):
    coef = np.exp(-alpha*alpha.conjugate()/2)
    list = [coef]
    for idx in range(1, n):
        coef *= alpha / np.sqrt(idx)
        list.append(coef)
    return np.array(list)

def d_coherent_coef_list(n, alpha):
    coef = np.exp(-alpha*alpha.conjugate()/2)
    list = [coef]
    for idx in range(1, n):
        coef *= alpha / np.sqrt(idx)
        list.append(coef * 1j * idx)
    return np.array(list)

def d2_coherent_coef_list(n, alpha):
    coef = np.exp(-alpha*alpha.conjugate()/2)
    list = [coef]
    for idx in range(1, n):
        coef *= alpha / np.sqrt(idx)
        list.append(-coef * idx**2)
    return np.array(list)

def sum_of_basis(basis, coef_list) -> qt.Qobj:
    dims = basis[0].dims
    N = 1
    for x in dims[0]:
        N *= x

    state = qt.zero_ket(N, dims=dims)
    for idx in range(len(coef_list)):
        state += basis[idx] * coef_list[idx]
    return state.unit()

def projector_w_basis(basis: List[qt.Qobj]):
    projector = 0
    for ket in basis:
        projector = projector + ket * ket.dag()
    return projector

# ##############################################################################
def state_sets(
    h_space: HilbertSpace, 
    alpha: float, 
    returns=None,
    return_1darray=True
):
    """
    Default returns for copy and paste
    (
        anc_0, anc_1,
        sys_0_anc_0_even, sys_1_anc_0_even,
        sys_d0_anc_0_even, sys_d1_anc_0_even,
        sys_0_anc_1_even, sys_1_anc_1_even,
        sys_d0_anc_1_even, sys_d1_anc_1_even,
    )
    """
    resonator, tmon = h_space.subsys_list
    sys_dim, anc_dim = resonator.truncated_dim, tmon.truncated_dim

    h_space.generate_lookup()
    _, evecs = h_space.eigensys(evals_count=sys_dim*anc_dim)

    # basis
    drs_basis_anc_0 = []
    for idx_b in range(sys_dim):
        idx_d = h_space.dressed_index((idx_b, 0))
        if idx_d is not None:
            evec = evecs[idx_d]
            dorminant_idx_d = idx_b * tmon.truncated_dim + 0
            dorminant_val = evec[dorminant_idx_d, 0]
            evec /= (dorminant_val) / np.abs(dorminant_val)
            drs_basis_anc_0.append(evec)
    basis_num_0 = len(drs_basis_anc_0)
    if basis_num_0 < sys_dim:
        raise RuntimeError(f"Dressed \'coherent\' states with anc 0 are generated by fewer ({basis_num_0}) basis.")

    drs_basis_anc_1 = []
    for idx_b in range(sys_dim):
        idx_d = h_space.dressed_index((idx_b, 1))
        if idx_d is not None:
            evec = evecs[idx_d]
            dorminant_idx_d = idx_b * tmon.truncated_dim + 1
            dorminant_val = evec[dorminant_idx_d, 0]
            evec /= (dorminant_val) / np.abs(dorminant_val)
            drs_basis_anc_1.append(evec)
    basis_num_1 = len(drs_basis_anc_1)
    if basis_num_1 < sys_dim:
        raise RuntimeError(f"Dressed \'coherent\' states with anc 1 are generated by fewer ({basis_num_1}) basis.")

    # regular ancilla 0-1 states
    anc_0 = drs_basis_anc_0[0]
    anc_1 = drs_basis_anc_1[0]

    # even init states
    # coeff
    coef_alpha = coherent_coef_list(basis_num_0, alpha)
    coef_m_alpha = coherent_coef_list(basis_num_0, -alpha)
    coef_i_alpha = coherent_coef_list(basis_num_0, 1j * alpha)
    coef_mi_alpha = coherent_coef_list(basis_num_0, -1j * alpha)

    d_coef_alpha = d_coherent_coef_list(basis_num_0, alpha)
    d_coef_m_alpha = d_coherent_coef_list(basis_num_0, -alpha)
    d_coef_i_alpha = d_coherent_coef_list(basis_num_0, 1j * alpha)
    d_coef_mi_alpha = d_coherent_coef_list(basis_num_0, -1j * alpha)

    d2_coef_alpha = d2_coherent_coef_list(basis_num_0, alpha)
    d2_coef_m_alpha = d2_coherent_coef_list(basis_num_0, -alpha)
    d2_coef_i_alpha = d2_coherent_coef_list(basis_num_0, 1j * alpha)
    d2_coef_mi_alpha = d2_coherent_coef_list(basis_num_0, -1j * alpha)

    coef_alpha_anc_1 = coherent_coef_list(basis_num_1, alpha)
    coef_m_alpha_anc_1 = coherent_coef_list(basis_num_1, -alpha)
    coef_i_alpha_anc_1 = coherent_coef_list(basis_num_1, 1j * alpha)
    coef_mi_alpha_anc_1 = coherent_coef_list(basis_num_1, -1j * alpha)

    d_coef_alpha_anc_1 = d_coherent_coef_list(basis_num_1, alpha)
    d_coef_m_alpha_anc_1 = d_coherent_coef_list(basis_num_1, -alpha)
    d_coef_i_alpha_anc_1 = d_coherent_coef_list(basis_num_1, 1j * alpha)
    d_coef_mi_alpha_anc_1 = d_coherent_coef_list(basis_num_1, -1j * alpha)
    
    d2_coef_alpha_anc_1 = d2_coherent_coef_list(basis_num_1, alpha)
    d2_coef_m_alpha_anc_1 = d2_coherent_coef_list(basis_num_1, -alpha)
    d2_coef_i_alpha_anc_1 = d2_coherent_coef_list(basis_num_1, 1j * alpha)
    d2_coef_mi_alpha_anc_1 = d2_coherent_coef_list(basis_num_1, -1j * alpha)

    # states
    sys_0_anc_0_even = sum_of_basis(drs_basis_anc_0, coef_alpha + coef_m_alpha)
    sys_1_anc_0_even = sum_of_basis(drs_basis_anc_0, coef_i_alpha + coef_mi_alpha)
    sys_d0_anc_0_even = sum_of_basis(drs_basis_anc_0, d_coef_alpha + d_coef_m_alpha)
    sys_d1_anc_0_even = sum_of_basis(drs_basis_anc_0, d_coef_i_alpha + d_coef_mi_alpha)
    sys_d20_anc_0_even = sum_of_basis(drs_basis_anc_0, d2_coef_alpha + d2_coef_m_alpha)
    sys_d21_anc_0_even = sum_of_basis(drs_basis_anc_0, d2_coef_i_alpha + d2_coef_mi_alpha)

    sys_0_anc_1_even = sum_of_basis(drs_basis_anc_1, coef_alpha_anc_1 + coef_m_alpha_anc_1)
    sys_1_anc_1_even = sum_of_basis(drs_basis_anc_1, coef_i_alpha_anc_1 + coef_mi_alpha_anc_1)
    sys_d0_anc_1_even = sum_of_basis(drs_basis_anc_1, d_coef_alpha_anc_1 + d_coef_m_alpha_anc_1)
    sys_d1_anc_1_even = sum_of_basis(drs_basis_anc_1, d_coef_i_alpha_anc_1 + d_coef_mi_alpha_anc_1)
    sys_d20_anc_1_even = sum_of_basis(drs_basis_anc_1, d2_coef_alpha + d2_coef_m_alpha)
    sys_d21_anc_1_even = sum_of_basis(drs_basis_anc_1, d2_coef_i_alpha + d2_coef_mi_alpha)

    if returns is None:
        returns = [
            "anc_0", "anc_1",
            "sys_0_anc_0_even", "sys_1_anc_0_even",
            "sys_d0_anc_0_even", "sys_d1_anc_0_even",
            "sys_0_anc_1_even", "sys_1_anc_1_even",
            "sys_d0_anc_1_even", "sys_d1_anc_1_even",
        ]
    local_vars = locals()
    return_items = [local_vars[item] for item in returns]

    if return_1darray:
        return [state.data.toarray()[:, 0] for state in return_items]
    else:
        return return_items